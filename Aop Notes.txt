===========================================================================================================================================
 Tutorial 24 - Introduction to AOP:
 ----------------------------------

 AOP is just not a feature of Spring it actually a programming model.
 Problem with Functional Programming : We need to break the complexity in functions.
 
 Problem with OOP: Not all the task we need to do can be classified as Objects. 
 ex: logger() function in each of the class A, B and C.
 	
 	*	Too many relationships to the cross-cutting object. 
 	*	Code is still required in all the methods.
 	*	Cannot be changed all at once.

Cross Cutting Concerns:
-----------------------

Some functionalities which needs to be used by different objects and they may be not a part of your problem domain. Could be infrastructure 
related, security related and so on.
ex: Logging, Transactions, Security and so on.

Solution to above problem:
--------------------------

Instead of creating new Class for Logger we create an aspect. It can be considered as a Class with special priveleges.
* Inside the aspect we will do 'Aspect Configuration' telling to which all Classes or methods() this aspect applies to. This is difference
between an OOP and AOP.

Wrapping Aspect around methods():
---------------------------------
Aspect Code --> Target methods

Steps in AOP:
-------------

1. Identify and write the Aspects.
2. Configure where the aspects apply.

===========================================================================================================================================

 Tutorial 25 : Setting up AOP
 -----------------------------

 Dependencies:- 
* We need the Spring depency jars as usual for any spring project.
* AspectJ : aspectjrt.jar, aspectjweaver.jar, aopalliance.jar, cgilib.jar, asm-3.3.1.jar

===========================================================================================================================================

Tutorial 26 - Writing Our First Aspect Part 1
----------------------------------------------

Use Case : We will create a shape service to get the required shape object.
In order to create the spring.xml file we need to include namespace for "aspectj-auto" to include <aop:> tags. Search for a file and copy
its header information having the above namespace. <aop: aspectj-autoproxy>

Here we have created a simple Spring flow where we are calling the getName() on shapeService to get the name of the subclass object.
What we will do in next tutorial is when ever we are calling the getName() we will create "Logging" aspect to record it.

===========================================================================================================================================

Tutorial 27 - Writing Our First Aspect Part 2
----------------------------------------------

We are creating a logging aspect. Aspect a special class. LoggingAspect.
The methods inside the Aspect are called Advice. AOP terminology. We can apply this advice on other spring container methods.
For turning a class into Aspect annotate it with @Aspect. That's it. 

Annotations on advice methods:
@Before : Run our advice methods before any target methods. ex : @Before("execution(public String getName())"); Whenever any getName()
		  method is run by Spring Container, run the advice method first.

The above method will run for every getName() method in our Spring Application.		  

We need to make sure that the spring.xml file is having the tag <aop:aspectj-autoproxy> and we give the aspect bean definition.
===========================================================================================================================================

Tutorial 28 - Pointcuts and Wildcard Expressions
------------------------------------------------

If we need to call advice on a specific methods provide the full path of the method from the base package.
ex: @Before("execution(public String com.ashish.aoptutorial.model.Circle.getName())")
	public void loggingAdvice(){}

1. One Advice applied to different points:
------------------------------------------

ex: Logging advice should run before all the getters of the application irrespective of their return type.
We can do this with the help of wild cards. It applies before all getters of all type and public methods.
@Before("execution(public * get*())")
public void loggingAdvice(){}

ex: should not worry about the access modifier of the methods:
@Before("execution(* get*())")
public void loggingAdvice(){}

ex: should apply to all getters with 1 or arguments:
@Before("execution(* get*(*))")
public void loggingAdvice(){}

ex: should apply to all getters with 0 or more arguments:
@Before("execution(* get*(..))")
public void loggingAdvice(){}

In the above ways we can apply single advice to different points in our code.

2. Multiple advices onto a single point:
----------------------------------------

For this we can create another advice methods and configure to run before the target methods. This will increase the reduncancy as we keep
on writing the same configuration multiple times. To avoid this we can create "POINTCUTS".
A Pointcut is a point in the app where you can cut in some code.
Once the pointcut is created we can refer it to all the advices and multiple advices can run on same points in the app.


===========================================================================================================================================
